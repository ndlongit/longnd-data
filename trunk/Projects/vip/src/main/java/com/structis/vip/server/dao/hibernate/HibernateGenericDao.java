/*
 * Generated by Celerio, a Jaxio tool. http://www.jaxio.com/
 */
package com.structis.vip.server.dao.hibernate;

import java.io.Serializable;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.Id;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.Transient;

import org.apache.commons.lang.Validate;
import org.apache.commons.lang.WordUtils;
import org.apache.log4j.Logger;
import org.hibernate.Criteria;
import org.hibernate.Session;
import org.hibernate.criterion.Criterion;
import org.hibernate.criterion.Junction;
import org.hibernate.criterion.Projections;
import org.hibernate.criterion.Restrictions;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Transactional;

import com.structis.vip.server.bean.domain.core.Identifiable;
import com.structis.vip.server.dao.support.GenericDao;
import com.structis.vip.server.dao.support.NamedQueryUtil;
import com.structis.vip.server.dao.support.SearchTemplate;


/**
 * Partial Hibernate implementation of the GenericDao interface.<br>
 * The exceptions are converted to generic spring unchecked exceptions.<br>
 */
public abstract class HibernateGenericDao<E extends Identifiable<PK>, PK extends Serializable>
		implements GenericDao<E, PK> {

	private Class<E> type;
	private Logger logger;

	/**
	 * This constructor needs the real type of the generic type E so
	 * it can be passed to the entityManager.
	 */
	public HibernateGenericDao(Class<E> type) {
		this.type = type;
		this.logger = Logger.getLogger(getClass());
		this.cacheRegion = type.getCanonicalName();
	}

	/**
	 * {@inheritDoc}
	 */
	@Transactional(readOnly = true)
	public E get(E entity) {
		if (entity == null) {
			return null;
		}

		Serializable id = entity.getPrimaryKey();
		if (id == null) {
			return null;
		}

		E entityFound = getEntityManager().find(type, id);

		if (entityFound == null) {
			logger.warn("get returned null with pk=" + id);
		}

		return entityFound;
	}

	/**
	 * {@inheritDoc}
	 */
	@Transactional(readOnly = true)
	public void refresh(E entity) {
		if (entityManager.contains(entity)) {
			entityManager.refresh(entity);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@SuppressWarnings("unchecked")
	@Transactional(readOnly = true)
	public List<E> find(E entity, SearchTemplate searchTemplate) {
//		throw new RuntimeException ("HibernateGenericDAO.find(E,SearchTemplate) non utilisable");
		Validate.notNull(entity, "The passed entity cannot be null");
		SearchTemplate localSearchTemplate = getLocalSearchTemplate(searchTemplate);

		if (localSearchTemplate.hasNamedQuery()) {
			return (List<E>) getNamedQueryUtil().findByNamedQuery(
					localSearchTemplate, entity);
		}

		Criteria criteria = getCriteria(entity, localSearchTemplate);
		HibernateUtil.applyPaginationAndOrderOnCriteria(criteria,
				localSearchTemplate);

		// retrieve List via hibernate
		List<E> entities;

		entities = (List<E>) criteria.list();
		if (logger.isDebugEnabled()) {
			logger.debug("Returned " + entities.size() + " elements");
		}

		return entities;
	}

	/**
	 * {@inheritDoc}
	 */
	@Transactional(readOnly = true)
	public int findCount(E entity, SearchTemplate searchTemplate) {

		Validate.notNull(entity, "The entity cannot be null");
		SearchTemplate localSearchTemplate = getLocalSearchTemplate(searchTemplate);

		if (localSearchTemplate.hasNamedQuery()) {
			return getNamedQueryUtil().numberByNamedQuery(localSearchTemplate,
					entity).intValue();
		}

		Criteria criteria = getCriteria(entity, searchTemplate);
		criteria.setProjection(Projections.rowCount());

		Number count = (Number) criteria.uniqueResult();

		if (count != null) {
			return count.intValue();
		} else {
			logger.warn("findCount returned null!");
			return 0;
		}
	}

	/**
	 * Create a criteria with caching enabled
	 * 
	 * @param entity the entity to use in search by Example
	 * @param searchTemplate the specific parameters such as named queries, extra infos, limitations, order, ...
	 * @return an hibernate criteria
	 */
	protected Criteria getCriteria(E entity, SearchTemplate searchTemplate) {
		Criteria criteria = getCurrentSession().createCriteria(type);
		setUpCacheOnCriteria(criteria, searchTemplate);

		List<Criterion> criterions = getCriterions(entity, searchTemplate);
		for (Criterion criterion : criterions) {
			criteria.add(criterion); // AND
		}

		return criteria;
	}

	protected void setUpCacheOnCriteria(Criteria criteria,
			SearchTemplate searchTemplate) {
		if (searchTemplate.isCacheable()) {
			criteria.setCacheable(true);

			if (searchTemplate.hasCacheRegion()) {
				criteria.setCacheRegion(searchTemplate.getCacheRegion());
			} else {
				criteria.setCacheRegion(getCacheRegion());
			}
		}
	}

	protected List<Criterion> getCriterions(E entity,
			SearchTemplate searchTemplate) {
		List<Criterion> criterions = new ArrayList<Criterion>();

		// search by pattern
		Criterion patternCriterion = getByPattern(searchTemplate);
		if (patternCriterion != null) {
			criterions.add(patternCriterion);
		}

		// search by date range
		Criterion dateCriterion = getByDateCriterion(searchTemplate);
		if (dateCriterion != null) {
			criterions.add(dateCriterion);
		}

		// search by example
		Criterion exampleCriterion = getByExampleCriterion(entity,
				searchTemplate);
		if (exampleCriterion != null) {
			criterions.add(exampleCriterion);
		}

		return criterions;
	}

	protected Criterion getByPattern(SearchTemplate searchTemplate) {
		if (!searchTemplate.hasSearchPattern()) {
			return null;
		}

		// chope tous les attributs en inspectant tous les getters public 
		// dont type de retour == String, n'est pas transient, ni l'id
		List<String> columns = new ArrayList<String>();
		for (Method method : type.getMethods()) {
			if (Modifier.isPublic(method.getModifiers())
					&& method.getReturnType() == String.class
					&& method.getAnnotation(Transient.class) == null
					&& method.getAnnotation(Id.class) == null) {
				if (method.getParameterTypes().length == 0
						&& (method.getName().startsWith("get") || method
								.getName().startsWith("is"))) {
					String methodName = method.getName();
					if (methodName.startsWith("is")) {
						columns.add(WordUtils.uncapitalize(methodName
								.substring(2)));
					} else {
						columns.add(WordUtils.uncapitalize(methodName
								.substring(3)));
					}
				}
			}
		}
		return HibernateUtil.constructPattern(columns.toArray(new String[0]),
				searchTemplate);
	}

	protected Criterion getByDateCriterion(SearchTemplate searchTemplate) {
		return HibernateUtil.constructDate(searchTemplate);
	}

	protected Criterion getByExampleCriterion(E entity,
			SearchTemplate searchTemplate) {
		Criterion example = HibernateUtil.constructExample(entity,
				searchTemplate);
		List<Criterion> extras = getByExampleExtraCriterions(entity,
				searchTemplate);

		if (extras != null && extras.size() > 0) {
			Junction conjunction = Restrictions.conjunction();
			for (Criterion extra : extras) {
				conjunction.add(extra);
			}
			conjunction.add(example);
			return conjunction;
		} else {
			return example;
		}
	}

	/**
	 * Subclass may provide extra criterion. Used along with search by example. Default implementation does nothing. Principal use case is to add criterion so
	 * the id fields part of the composite primary key are included in a search by example.
	 * 
	 * @param entity
	 * @param searchTemplate
	 * @return a criterion that will be appended (AND) to the example criterion. Null if no criterion should be appended.
	 */
	protected List<Criterion> getByExampleExtraCriterions(E entity,
			SearchTemplate searchTemplate) {
		return null;
	}

	/**
	 * {@inheritDoc}
	 */
	@Transactional
	public void save(E entity) {
		Validate.notNull(entity, "The entity to save cannot be null element");
		// persist brand new entity or entity whose primary is manually set.
		if (!entity.isPrimaryKeySet() || !getEntityManager().contains(entity)) {
			getEntityManager().persist(entity);
			getEntityManager().flush();			
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Transactional
	public void save(Iterable<E> entities) {
		Validate.notNull(entities, "The entities to save cannot be null");

		for (E entity : entities) {
			save(entity);
		}

		if (logger.isDebugEnabled()) {
			logger.debug("Save List done");
		}
	}
	
	@Transactional
	public void flush(){
		getEntityManager().flush();
	}

	
	/**
	 * {@inheritDoc}
	 */
	@Transactional
	public void delete(E entity) {
		if (getEntityManager().contains(entity)) {
			getEntityManager().remove(entity);
		} else {
			// could be a delete on a transient instance
			E entityRef = getEntityManager().getReference(type,
					entity.getPrimaryKey());

			if (entityRef != null) {
				getEntityManager().remove(entityRef);
			} else {
				logger
						.warn("Attempt to delete an instance that is not present in the database: "
								+ entity.toString());
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Transactional
	public void delete(Iterable<E> entities) {
		Validate.notNull(entities, "Cannot delete null collection");
		for (E entity : entities) {
			delete(entity);
		}
	}

	/**
	 * Create a new search template, taking into account the passed searchTemplate and the cacheable and cacheRegion properties of this instance.
	 */
	public SearchTemplate getLocalSearchTemplate(SearchTemplate searchTemplate) {
		if (searchTemplate == null) {
			SearchTemplate localSearchTemplate = new SearchTemplate();
			localSearchTemplate.setCacheable(getCacheable());
			localSearchTemplate.setCacheRegion(getCacheRegion());
			return localSearchTemplate;
		}

		SearchTemplate localSearchTemplate = new SearchTemplate(searchTemplate);

		if (searchTemplate.isCacheable() == null) {
			localSearchTemplate.setCacheable(getCacheable());
		}

		if (!searchTemplate.hasCacheRegion()) {
			localSearchTemplate.setCacheRegion(getCacheRegion());
		}

		return localSearchTemplate;
	}

	/**
	 * Simple helper to obtain the current Session.
	 */
	protected Session getCurrentSession() {
		return (Session) getEntityManager().getDelegate();
	}

	// ------------------------------------------
	// Dependencies
	// ------------------------------------------
	private NamedQueryUtil namedQueryUtil;
	private EntityManager entityManager;

	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	public EntityManager getEntityManager() {
		return entityManager;
	}

	@Autowired
	public void setNamedQueryUtil(NamedQueryUtil namedQueryUtil) {
		this.namedQueryUtil = namedQueryUtil;
	}

	public NamedQueryUtil getNamedQueryUtil() {
		return namedQueryUtil;
	}

	// ------------------------------------------
	// Configuration
	// ------------------------------------------
	private boolean cacheable = true;
	private String cacheRegion;

	/**
	 * Set the default cacheable property to be used when the searchTemplate argument is null or do not specify one.
	 */
	public void setCacheable(boolean cacheable) {
		this.cacheable = cacheable;
	}

	public boolean getCacheable() {
		return cacheable;
	}

	/**
	 * Set the default cacheRegion property to use when the searchTemplate argument is null or do not specify one.
	 */
	public void setCacheRegion(String cacheRegion) {
		this.cacheRegion = cacheRegion;
	}

	public String getCacheRegion() {
		return cacheRegion;
	}

	protected Query createQuery(String sql) {
		return getEntityManager().createQuery(sql);
	}	

	@SuppressWarnings("unchecked")
	protected List<E> getResultList(Query query) {
		if (query == null) {
			return new ArrayList<E>();
		} else {
			return (List<E>) query.getResultList();
		}
	}
}
