/*
 * Generated by Celerio, a Jaxio tool. http://www.jaxio.com/
 */
package com.structis.vip.server.dao.hibernate;

import java.io.Serializable;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.Id;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.Transient;

import org.apache.commons.lang.Validate;
import org.apache.commons.lang.WordUtils;
import org.apache.log4j.Logger;
import org.hibernate.Criteria;
import org.hibernate.Session;
import org.hibernate.criterion.Criterion;
import org.hibernate.criterion.Junction;
import org.hibernate.criterion.Projections;
import org.hibernate.criterion.Restrictions;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Transactional;

import com.structis.vip.server.bean.domain.core.Identifiable;
import com.structis.vip.server.dao.support.GenericDao;
import com.structis.vip.server.dao.support.NamedQueryUtil;
import com.structis.vip.server.dao.support.SearchTemplate;

/**
 * Partial Hibernate implementation of the GenericDao interface.<br>
 * The exceptions are converted to generic spring unchecked exceptions.<br>
 */
public abstract class HibernateGenericDao<E extends Identifiable<PK>, PK extends Serializable> implements GenericDao<E, PK> {

    private Class<E> type;
    private Logger logger;

    /**
     * This constructor needs the real type of the generic type E so it can be passed to the entityManager.
     */
    public HibernateGenericDao(Class<E> type) {
        this.type = type;
        this.logger = Logger.getLogger(this.getClass());
        this.cacheRegion = type.getCanonicalName();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional(readOnly = true)
    public E get(E entity) {
        if (entity == null) {
            return null;
        }

        Serializable id = entity.getPrimaryKey();
        if (id == null) {
            return null;
        }

        E entityFound = this.getEntityManager().find(this.type, id);

        if (entityFound == null) {
            this.logger.warn("get returned null with pk=" + id);
        }

        return entityFound;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional(readOnly = true)
    public void refresh(E entity) {
        if (this.entityManager.contains(entity)) {
            this.entityManager.refresh(entity);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @SuppressWarnings("unchecked")
    @Transactional(readOnly = true)
    public List<E> find(E entity, SearchTemplate searchTemplate) {
        // throw new RuntimeException ("HibernateGenericDAO.find(E,SearchTemplate) non utilisable");
        Validate.notNull(entity, "The passed entity cannot be null");
        SearchTemplate localSearchTemplate = this.getLocalSearchTemplate(searchTemplate);

        if (localSearchTemplate.hasNamedQuery()) {
            return (List<E>) this.getNamedQueryUtil().findByNamedQuery(localSearchTemplate, entity);
        }

        Criteria criteria = this.getCriteria(entity, localSearchTemplate);
        HibernateUtil.applyPaginationAndOrderOnCriteria(criteria, localSearchTemplate);

        // retrieve List via hibernate
        List<E> entities;

        entities = criteria.list();
        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Returned " + entities.size() + " elements");
        }

        return entities;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional(readOnly = true)
    public int findCount(E entity, SearchTemplate searchTemplate) {

        Validate.notNull(entity, "The entity cannot be null");
        SearchTemplate localSearchTemplate = this.getLocalSearchTemplate(searchTemplate);

        if (localSearchTemplate.hasNamedQuery()) {
            return this.getNamedQueryUtil().numberByNamedQuery(localSearchTemplate, entity).intValue();
        }

        Criteria criteria = this.getCriteria(entity, searchTemplate);
        criteria.setProjection(Projections.rowCount());

        Number count = (Number) criteria.uniqueResult();

        if (count != null) {
            return count.intValue();
        } else {
            this.logger.warn("findCount returned null!");
            return 0;
        }
    }

    /**
     * Create a criteria with caching enabled
     * 
     * @param entity
     *            the entity to use in search by Example
     * @param searchTemplate
     *            the specific parameters such as named queries, extra infos, limitations, order, ...
     * @return an hibernate criteria
     */
    protected Criteria getCriteria(E entity, SearchTemplate searchTemplate) {
        Criteria criteria = this.getCurrentSession().createCriteria(this.type);
        this.setUpCacheOnCriteria(criteria, searchTemplate);

        List<Criterion> criterions = this.getCriterions(entity, searchTemplate);
        for (Criterion criterion : criterions) {
            criteria.add(criterion); // AND
        }

        return criteria;
    }

    protected void setUpCacheOnCriteria(Criteria criteria, SearchTemplate searchTemplate) {
        if (searchTemplate.isCacheable()) {
            criteria.setCacheable(true);

            if (searchTemplate.hasCacheRegion()) {
                criteria.setCacheRegion(searchTemplate.getCacheRegion());
            } else {
                criteria.setCacheRegion(this.getCacheRegion());
            }
        }
    }

    protected List<Criterion> getCriterions(E entity, SearchTemplate searchTemplate) {
        List<Criterion> criterions = new ArrayList<Criterion>();

        // search by pattern
        Criterion patternCriterion = this.getByPattern(searchTemplate);
        if (patternCriterion != null) {
            criterions.add(patternCriterion);
        }

        // search by date range
        Criterion dateCriterion = this.getByDateCriterion(searchTemplate);
        if (dateCriterion != null) {
            criterions.add(dateCriterion);
        }

        // search by example
        Criterion exampleCriterion = this.getByExampleCriterion(entity, searchTemplate);
        if (exampleCriterion != null) {
            criterions.add(exampleCriterion);
        }

        return criterions;
    }

    protected Criterion getByPattern(SearchTemplate searchTemplate) {
        if (!searchTemplate.hasSearchPattern()) {
            return null;
        }

        // chope tous les attributs en inspectant tous les getters public
        // dont type de retour == String, n'est pas transient, ni l'id
        List<String> columns = new ArrayList<String>();
        for (Method method : this.type.getMethods()) {
            if (Modifier.isPublic(method.getModifiers()) && method.getReturnType() == String.class && method.getAnnotation(Transient.class) == null
                    && method.getAnnotation(Id.class) == null) {
                if (method.getParameterTypes().length == 0 && (method.getName().startsWith("get") || method.getName().startsWith("is"))) {
                    String methodName = method.getName();
                    if (methodName.startsWith("is")) {
                        columns.add(WordUtils.uncapitalize(methodName.substring(2)));
                    } else {
                        columns.add(WordUtils.uncapitalize(methodName.substring(3)));
                    }
                }
            }
        }
        return HibernateUtil.constructPattern(columns.toArray(new String[0]), searchTemplate);
    }

    protected Criterion getByDateCriterion(SearchTemplate searchTemplate) {
        return HibernateUtil.constructDate(searchTemplate);
    }

    protected Criterion getByExampleCriterion(E entity, SearchTemplate searchTemplate) {
        Criterion example = HibernateUtil.constructExample(entity, searchTemplate);
        List<Criterion> extras = this.getByExampleExtraCriterions(entity, searchTemplate);

        if (extras != null && extras.size() > 0) {
            Junction conjunction = Restrictions.conjunction();
            for (Criterion extra : extras) {
                conjunction.add(extra);
            }
            conjunction.add(example);
            return conjunction;
        } else {
            return example;
        }
    }

    /**
     * Subclass may provide extra criterion. Used along with search by example. Default implementation does nothing. Principal use case is to add
     * criterion so the id fields part of the composite primary key are included in a search by example.
     * 
     * @param entity
     * @param searchTemplate
     * @return a criterion that will be appended (AND) to the example criterion. Null if no criterion should be appended.
     */
    protected List<Criterion> getByExampleExtraCriterions(E entity, SearchTemplate searchTemplate) {
        return null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public void save(E entity) {
        Validate.notNull(entity, "The entity to save cannot be null element");
        // persist brand new entity or entity whose primary is manually set.
        if (!entity.isPrimaryKeySet() || !this.getEntityManager().contains(entity)) {
            this.getEntityManager().persist(entity);
            this.getEntityManager().flush();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public void save(Iterable<E> entities) {
        Validate.notNull(entities, "The entities to save cannot be null");

        for (E entity : entities) {
            this.save(entity);
        }

        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Save List done");
        }
    }

    @Override
    @Transactional
    public void flush() {
        this.getEntityManager().flush();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public void delete(E entity) {
        if (this.getEntityManager().contains(entity)) {
            this.getEntityManager().remove(entity);
        } else {
            // could be a delete on a transient instance
            E entityRef = this.getEntityManager().getReference(this.type, entity.getPrimaryKey());

            if (entityRef != null) {
                this.getEntityManager().remove(entityRef);
            } else {
                this.logger.warn("Attempt to delete an instance that is not present in the database: " + entity.toString());
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public void delete(Iterable<E> entities) {
        Validate.notNull(entities, "Cannot delete null collection");
        for (E entity : entities) {
            this.delete(entity);
        }
    }

    /**
     * Create a new search template, taking into account the passed searchTemplate and the cacheable and cacheRegion properties of this instance.
     */
    public SearchTemplate getLocalSearchTemplate(SearchTemplate searchTemplate) {
        if (searchTemplate == null) {
            SearchTemplate localSearchTemplate = new SearchTemplate();
            localSearchTemplate.setCacheable(this.getCacheable());
            localSearchTemplate.setCacheRegion(this.getCacheRegion());
            return localSearchTemplate;
        }

        SearchTemplate localSearchTemplate = new SearchTemplate(searchTemplate);

        if (searchTemplate.isCacheable() == null) {
            localSearchTemplate.setCacheable(this.getCacheable());
        }

        if (!searchTemplate.hasCacheRegion()) {
            localSearchTemplate.setCacheRegion(this.getCacheRegion());
        }

        return localSearchTemplate;
    }

    /**
     * Simple helper to obtain the current Session.
     */
    protected Session getCurrentSession() {
        return (Session) this.getEntityManager().getDelegate();
    }

    // ------------------------------------------
    // Dependencies
    // ------------------------------------------
    private NamedQueryUtil namedQueryUtil;
    private EntityManager entityManager;

    @PersistenceContext
    public void setEntityManager(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    public EntityManager getEntityManager() {
        return this.entityManager;
    }

    @Autowired
    public void setNamedQueryUtil(NamedQueryUtil namedQueryUtil) {
        this.namedQueryUtil = namedQueryUtil;
    }

    public NamedQueryUtil getNamedQueryUtil() {
        return this.namedQueryUtil;
    }

    // ------------------------------------------
    // Configuration
    // ------------------------------------------
    private boolean cacheable = true;
    private String cacheRegion;

    /**
     * Set the default cacheable property to be used when the searchTemplate argument is null or do not specify one.
     */
    public void setCacheable(boolean cacheable) {
        this.cacheable = cacheable;
    }

    public boolean getCacheable() {
        return this.cacheable;
    }

    /**
     * Set the default cacheRegion property to use when the searchTemplate argument is null or do not specify one.
     */
    public void setCacheRegion(String cacheRegion) {
        this.cacheRegion = cacheRegion;
    }

    public String getCacheRegion() {
        return this.cacheRegion;
    }

    protected Query createQuery(String sql) {
        return this.getEntityManager().createQuery(sql);
    }

    @SuppressWarnings("unchecked")
    protected List<E> getResultList(Query query) {
        if (query == null) {
            return new ArrayList<E>();
        } else {
            return query.getResultList();
        }
    }
}
